#!/usr/bin/env python

# full width horizontal bar at top to search
# left column with current results: name, mod date, summary, tags
# right column with text of currently selected note

import os
import Tkinter as tk
from ScrolledText import ScrolledText
import tkMessageBox
import tkFileDialog
import tkSimpleDialog
import sys


class WidgetRedirector:

    """Support for redirecting arbitrary widget subcommands."""

    def __init__(self, widget):
        self.dict = {}
        self.widget = widget
        self.tk = tk = widget.tk
        w = widget._w
        self.orig = w + "_orig"
        tk.call("rename", w, self.orig)
        tk.createcommand(w, self.dispatch)

    def __repr__(self):
        return "WidgetRedirector(%s<%s>)" % (self.widget.__class__.__name__,
                                             self.widget._w)

    def close(self):
        for name in self.dict.keys():
            self.unregister(name)
        widget = self.widget; del self.widget
        orig = self.orig; del self.orig
        tk = widget.tk
        w = widget._w
        tk.deletecommand(w)
        tk.call("rename", orig, w)

    def register(self, name, function):
        if self.dict.has_key(name):
            previous = dict[name]
        else:
            previous = OriginalCommand(self, name)
        self.dict[name] = function
        setattr(self.widget, name, function)
        return previous

    def unregister(self, name):
        if self.dict.has_key(name):
            function = self.dict[name]
            del self.dict[name]
            if hasattr(self.widget, name):
                delattr(self.widget, name)
            return function
        else:
            return None

    def dispatch(self, cmd, *args):
        m = self.dict.get(cmd)
        try:
            if m:
                return m(*args)
            else:
                return self.tk.call((self.orig, cmd) + args)
        except tk.TclError:
            return ""


class OriginalCommand:

    def __init__(self, redir, name):
        self.redir = redir
        self.name = name
        self.tk = redir.tk
        self.orig = redir.orig
        self.tk_call = self.tk.call
        self.orig_and_name = (self.orig, self.name)

    def __repr__(self):
        return "OriginalCommand(%r, %r)" % (self.redir, self.name)

    def __call__(self, *args):
        return self.tk_call(self.orig_and_name + args)


#########################################################################
class RedirectedText(tk.Text):
    """We would like to know when the Text widget's contents change.  We can't
    just override the insert method, we have to make use of some Tk magic.
    This magic is encapsulated in the idlelib.WidgetRedirector class which
    we use here.
    """

    def __init__(self, master=None, cnf={}, **kw):
        tk.Text.__init__(self, master, cnf, **kw)

        # now attach the redirector
        self.redir = WidgetRedirector(self)
        self.orig_insert = self.redir.register("insert", self.new_insert)
        self.orig_delete = self.redir.register("delete", self.new_delete)

    def new_insert(self, *args):
        self.orig_insert(*args)
        self.event_generate('<<Change>>')

    def new_delete(self, *args):
        self.orig_delete(*args)
        self.event_generate('<<Change>>')


class View:
    """Main user interface class.
    """
    
    def __init__(self, controller):
        self.controller = controller

        self.root = None

        self._create_ui()
        self._bind_events()

        #self._current_text = None
        #self.user_text.focus_set()
        
    def _bind_events(self):
        self.root.bind_all("<Control-f>", lambda e: self.search_entry.focus())        

    def _create_menu(self):
        """Utility function to setup main menu.

        Called by _create_ui.
        """
        
        # MAIN MENU ####################################################
        menu = tk.Menu(self.root)
        self.root.config(menu=menu)

        file_menu = tk.Menu(menu, tearoff=False)
        menu.add_cascade(label="File", underline='0', menu=file_menu)
        

        # FILE ##########################################################
        file_menu.add_command(label = "Exit", underline=1,
                              command=self.cmd_exit, accelerator="Ctrl+Q")
        self.root.bind_all("<Control-q>", self.cmd_exit)

        # EDIT ##########################################################
        edit_menu = tk.Menu(menu, tearoff=False)
        menu.add_cascade(label="Edit", underline=0, menu=edit_menu)
        
        edit_menu.add_command(label="Cut", accelerator="Ctrl+X",
                              underline=2, command=self.cmd_cut)
        edit_menu.add_command(label="Copy", accelerator="Ctrl+C",
                              underline=0, command=self.cmd_copy)
        edit_menu.add_command(label="Paste", accelerator="Ctrl+V",
                              underline=0, command=self.cmd_paste)


        # HELP ##########################################################
        help_menu = tk.Menu(menu, tearoff=False)
        menu.add_cascade(label="Help", underline='0', menu=help_menu)

        help_menu.add_command(label = "About", underline = 0,
                              command = self.cmd_help_about)

        # END MENU ######################################################

    def _create_ui(self):

        # these two variables determine the final dimensions of our interface
        #FRAME_HEIGHT=400
        TEXT_WIDTH=80
        
        self.root = tk.Tk()
        self.root.title("nvPY")

        # try finding icon in resdir and in appdir
#        try:
#            self.iconpath = os.path.join(
#                self.controller.get_resdir(), 'envedit.ico')
#            self.root.iconbitmap(self.iconpath)
            
#        except TclError:
#            try:
#                self.iconpath = os.path.join(
#                    self.controller.get_appdir(), 'envedit.ico')
#                self.root.iconbitmap(self.iconpath)
                
#            except TclError:
#                self.show_error('Error', 'Error opening icon.  Continuing.')

        # create menu ###################################################
        self._create_menu()

        # separator after menu ##########################################
        #separator = tk.Frame(self.root, height=2, bd=1, relief=tk.SUNKEN)
        #separator.pack(fill=tk.X, padx=5, pady=2, side=tk.TOP)

        # setup statusbar ###############################################
        # first pack this before panedwindow, else behaviour is unexpected
        # during sash moving and resizing
        #self.statusbar = StatusBar(self.root)
        #self.statusbar.set('%s', 'Welcome to envedit!')
        #self.statusbar.pack(fill=X, side=BOTTOM)
        
        search_frame = tk.Frame(self.root)
        self.search_entry = tk.Entry(search_frame)
        self.search_entry.pack(fill=tk.X)
        
        search_frame.pack(side=tk.TOP, fill=tk.X)
        
        # the paned window ##############################################
        paned_window = tk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        paned_window.pack(fill=tk.BOTH, expand=1)
        
        left_frame = tk.Frame(paned_window, width=100)
        paned_window.add(left_frame)

        right_frame = tk.Frame(paned_window, width=400)
        paned_window.add(right_frame)

        # we'll use this method to create the different edit boxes
        def create_scrolled_text(master, label_text):

            label_frame = tk.Frame(master)

            l = tk.Label(label_frame, text = label_text,
                       anchor = tk.W)
            l.pack(side=tk.LEFT)

            mode_label_var = tk.StringVar()
            mode_label_var.set("")
            ml = tk.Label(label_frame, textvariable = mode_label_var, anchor = tk.W)
            ml.pack(side=tk.LEFT)

            label_frame.pack()

            yscrollbar = tk.Scrollbar(master)
            yscrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            # this determines the width of the complete interface (yes)
            text = RedirectedText(master, height=15, width=TEXT_WIDTH,
                                  wrap=tk.CHAR,
                                  yscrollcommand=yscrollbar.set)

            text.pack(fill=tk.BOTH, expand=1)

            #xscrollbar.config(command=text.xview)
            yscrollbar.config(command=text.yview)

            return text, mode_label_var


        # setup user_text ###############################################
        self.user_text, self._user_mode_label_var = \
                        create_scrolled_text(right_frame, "User Environment")

#        def cb_ut_fi(event):
#            self.set_current_text(CURTEXT_USER)
#
#        self.user_text.bind('<FocusIn>', cb_ut_fi)
#
#        def cb_ut_m(event):
#            self.set_user_mode(MODE_MODIFIED)
#
#        self.user_text.bind('<<Change>>', cb_ut_m)
#
#        # setup sys_text ################################################
#        self.sys_text, self._sys_mode_label_var = \
#                      create_scrolled_text(bottom_frame, "System Environment")
#
#        def cb_st_fi(event):
#            self.set_current_text(CURTEXT_SYS)
#
#        self.sys_text.bind('<FocusIn>', cb_st_fi)
#
#        def cb_st_c(event):
#            self.set_sys_mode(MODE_MODIFIED)
#            
#        self.sys_text.bind('<<Change>>', cb_st_c)

        # bind event to paned_window ####################################
        def event_configure(self, event=None):
            """At every configure event of the paned_window, check that the
            user hasn't shrunken the window so that one of the panes has
            completely disappeared.  If this is the case, reset the sash
            position to half-way.
            """
            
            sash_pos = paned_window.sash_coord(0)
            pw_height = paned_window.winfo_height()
            if sash_pos[1] + 20 > pw_height:
                paned_window.sash_place(0, sash_pos[0], pw_height / 2)
            
        paned_window.bind('<Configure>', event_configure)

        
        # finish UI creation ###########################################

        # call update so we know that sizes are up to date
        self.root.update_idletasks()
        # now set the minsize so that things can not disappear
        self.root.minsize(self.root.winfo_width(), self.root.winfo_height())

    def close(self):
        self.root.destroy()


    def cmd_cut(self):
        t = self.get_text_with_focus()
        if t:
            t.event_generate('<<Cut>>')

    def cmd_copy(self):
        t = self.get_text_with_focus()
        if t:
            t.event_generate('<<Copy>>')
        
    def cmd_paste(self):
        t = self.get_text_with_focus()
        if t:
            t.event_generate('<<Paste>>')


    def cmd_help_about(self):
        tkMessageBox.showinfo(
            'Help | About',
            'nvPY %s is copyright 2012 by Charl P. Botha '
            '<http://charlbotha.com/>\n\n'
            'Because SimpleNote deserves better.' % (self.controller.get_version(),),
            parent = self.root)

    def cmd_exit(self, event=None):
        self.controller.quit()

    def main_loop(self):
        self.root.mainloop()

    def show_error(self, title, msg):
        tkMessageBox.showerror(title, msg)


class Controller:
    """Main application class.
    """
    
    def __init__(self):
        # setup appdir
        if hasattr(sys, 'frozen') and sys.frozen:
            self._appdir, exe = os.path.split(sys.executable)
        else:
            dirname = os.path.dirname(sys.argv[0])
            if dirname and dirname != os.curdir:
                self._appdir = dirname
            else:
                self._appdir = os.getcwd()

        
        # create the interface
        self.view = View(self)

    def get_appdir(self):
        return self._appdir

    def get_resdir(self):
        return os.path.join(self.get_appdir(), 'resources')
    
    def get_version(self):
        return "0.2"

    def quit(self):
        self.view.close()
        
    def main_loop(self):
        self.view.main_loop()


def main():
    controller = Controller()
    controller.main_loop()
    

if __name__ == '__main__':
    main()

